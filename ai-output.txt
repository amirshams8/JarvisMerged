// ===== FILE: modules/core/src/main/java/com/jarvismini/core/JarvisState.kt =====
package com.jarvismini.core

import android.content.Context

object JarvisState {

    private const val PREFS = "jarvis_state"
    private const val KEY_MODE = "mode"

    var currentMode: JarvisMode = JarvisMode.NORMAL
        private set

    fun init(context: Context) {
        val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
        val saved = prefs.getString(KEY_MODE, JarvisMode.NORMAL.name)
        currentMode = JarvisMode.valueOf(saved!!)
    }

    fun setMode(context: Context, mode: JarvisMode) {
        currentMode = mode
        context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .edit()
            .putString(KEY_MODE, mode.name)
            .apply()
    }
}
// ===== FILE: app/src/main/kotlin/com/jarvismini/CoreApp.kt =====
package com.jarvismini

import android.app.Application
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisState

class CoreApp : Application() {

    override fun onCreate() {
        super.onCreate()

        JarvisState.init(this)
        AutoReplyOrchestrator.init()
    }
}
// ===== FILE: app/src/main/java/com/jarvismini/MainActivity.kt =====
package com.jarvismini

import android.app.role.RoleManager
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

class MainActivity : AppCompatActivity() {

    private lateinit var statusText: TextView
    private lateinit var modeSpinner: Spinner
    private lateinit var enableCallButton: Button

    private val PERM_REQ = 2001

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        JarvisState.init(this)
        requestPermissions()

        statusText = TextView(this).apply {
            text = "Current mode: ${JarvisState.currentMode}"
            textSize = 16f
        }

        modeSpinner = Spinner(this)
        val modes = JarvisMode.values().map { it.name }
        modeSpinner.adapter =
            ArrayAdapter(this, android.R.layout.simple_spinner_item, modes)

        modeSpinner.setSelection(JarvisMode.values().indexOf(JarvisState.currentMode))

        modeSpinner.onItemSelectedListener =
            object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(
                    parent: AdapterView<*>,
                    view: View?,
                    pos: Int,
                    id: Long
                ) {
                    val mode = JarvisMode.valueOf(modes[pos])
                    JarvisState.setMode(this@MainActivity, mode)
                    statusText.text = "Current mode: $mode"
                }

                override fun onNothingSelected(parent: AdapterView<*>) {}
            }

        enableCallButton = Button(this).apply {
            text = "Enable Call Auto-Reply"
            setOnClickListener { requestCallScreeningRole() }
        }

        val layout = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            addView(statusText)
            addView(modeSpinner)
            addView(enableCallButton)
        }

        setContentView(layout)
    }

    private fun requestCallScreeningRole() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) return

        val roleManager = getSystemService(RoleManager::class.java)

        if (roleManager.isRoleAvailable(RoleManager.ROLE_CALL_SCREENING)
            && !roleManager.isRoleHeld(RoleManager.ROLE_CALL_SCREENING)
        ) {
            startActivity(
                roleManager.createRequestRoleIntent(
                    RoleManager.ROLE_CALL_SCREENING
                )
            )
        } else {
            Toast.makeText(this, "Call screening already enabled", Toast.LENGTH_SHORT).show()
        }
    }

    private fun requestPermissions() {
        val perms = mutableListOf<String>()

        if (ContextCompat.checkSelfPermission(
                this,
                android.Manifest.permission.READ_CONTACTS
            ) != PackageManager.PERMISSION_GRANTED
        ) perms += android.Manifest.permission.READ_CONTACTS

        if (ContextCompat.checkSelfPermission(
                this,
                android.Manifest.permission.SEND_SMS
            ) != PackageManager.PERMISSION_GRANTED
        ) perms += android.Manifest.permission.SEND_SMS

        if (perms.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, perms.toTypedArray(), PERM_REQ)
        }
    }
}
// ===== FILE: modules/callhandler/src/main/java/com/jarvismini/callhandler/JarvisCallScreeningService.kt =====
package com.jarvismini.callhandler

import android.net.Uri
import android.provider.ContactsContract
import android.telecom.Call
import android.telecom.CallScreeningService
import android.telephony.SmsManager
import android.util.Log
import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

class JarvisCallScreeningService : CallScreeningService() {

    override fun onScreenCall(details: Call.Details) {
        val number = details.handle?.schemeSpecificPart ?: return

        // Jarvis OFF â†’ do nothing
        if (JarvisState.currentMode == JarvisMode.NORMAL) {
            allow()
            return
        }

        // Contacts only
        if (!isContact(number)) {
            allow()
            return
        }

        val decision = AutoReplyOrchestrator.handle(
            AutoReplyInput("Incoming call", false)
        )

        if (decision is ReplyDecision.AutoReply) {
            SmsManager.getDefault()
                .sendTextMessage(number, null, decision.message, null, null)

            reject()
        } else {
            allow()
        }
    }

    private fun allow() {
        respondToCall(CallResponse.Builder().build())
    }

    private fun reject() {
        respondToCall(
            CallResponse.Builder()
                .setDisallowCall(true)
                .setRejectCall(true)
                .setSkipNotification(true)
                .setSkipCallLog(true)
                .build()
        )
    }

    private fun isContact(number: String): Boolean {
        val uri = Uri.withAppendedPath(
            ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
            Uri.encode(number)
        )

        contentResolver.query(uri, null, null, null, null).use {
            return it?.moveToFirst() == true
        }
    }
}
